* RELEASE PLAN FOR 3.0
  - check the option of not generating functions, and deferred
    generation in general
    - check if break/return works as expected and write tests!!!
    - check the "final comments problem" and describe it
  - Improve the documentation
    +- check exisiting TODOs
    - integrate new syntax changes
      - include and import
      - no more wrapper class
      - "{exp}" syntax for field access
      - cast expressions
      - lambda expressions
      - type declarations for external fields/methods
  +- Get rid of wrapper class, and remove special loading of type
     definitions except for Agent.rudi: seems to work fine!
     - Drawback: you can not change functionality in Agent
       (framework), for example Behaviour handling. That is definitely
       a drawback!

  + replace import by include
  + allow Java import statements at beginning of file only
    + bison grammar adapted
    + java imports have to be generated (currently ignored) + generation tested
    + Für .rudi files "include" statt "import" benutzen !!! JA FÜR 3.0
      + "import" wie in Java nur am Anfang des Files zulassen, dass dann auch
         nur Java imports macht?
  + field access conflicts: solved
    + use "{exp}" syntax for property access, otherwise unexpected stuff
      happens.
    + Add it to AllYouCanDo.rudi and tests
  + get rid of reduce reduce conflicts
    + Übrige reduce-reduce Konflikte durch Syntax-Änderungen lösen, z.B.
      cast(TypeExpr, expr) statt (typeexpr) expr (oder isa statt cast)
    + simplest problem are the field/method defs, they could be later generated
      from a java parser/introspection
    + cast expressions --> `isa` infix operator: isa(type_expr, exp)
    + ARROW --> `lambda` infix operator: lambda(arg0, ...) exp | body
  + check the option of not generating functions, and deferred
    generation in general
    + some things still move, since they need to be on top level,
      together with the process() function:
      + Field defs, to the front, but if they are combined with
        assignments, these will appear later
      + Method defs, they are currently deferred to the back
    + problem of "moving comments and injected java code" remains,
      but solution might be to pick comments *BETWEEN* two elements,
      is almost gone, but no guarantee due to moving code, and
      end-of-file situations, which can not be really fixed (code in
      or out of scope of process(){...}
    + check how good the comment handling really works
  + get rid of reduce reduce conflicts
    + remove ARROW token, unused
    + integrate with the rest

* Erleuchtung bzgl. Wrapperklasse: Agent vs. NaoAgent vs. PalAgent !!! JA FÜR 3.0
  1. NaoAgent scheint eigentlich eine klasse wie TimelineUtils zu sein (oder
     könnte so sein)
  2. Sollten PalAgent und NaoAgent nicht die Plätze tauschen, also:
     NaoAgent extends PalAgent, und nicht umgekehrt.
  3. PalAgent wird nur einmal erzeugt, und alle Variablen und Methoden stehen
     also zur Verfügung, auch die nicht-statischen! Damit kann man aus
     Java-Klassen .rudi Methoden benutzen!
     Ausprobieren mit endQuiz (im Moment in NaoAgent)
* Bringt die baumartige Struktur überhaupt Vorteile? Alternativen?
* Sollte man für die "if"s überhaupt Funktionen/Methoden generieren?
  Evtl. könnte man so das Problem mit der linearisierung von input und output
  code leichter lösen
* Kann man die Generierung besser in eine eigene Stage verschieben?
  die für sich genommen einfacher oder zumindest durchsichtiger ist?
* Besseres plug-in für NLU/NLG/ASR/TTS über injection?
  - Die Funktionalität jetzt ist eigentlich ganz OK und funktioniert
  - rasa / Lucene / OpenNLP NLU als default-alternative
  - cplanner zur Luxus-NLG umbauen
  - Anschluss von vosk und anderen ASRs als modul, TTS?
* Developer Tools?
  - Syntax-Highlighting f. VS Code? Anbindung an Rudibugger?
  - Analyse von Java-Klassen z. automatischen Extraktion von Feld-
    und Methodensignaturen?
* Queries aus .rudi abfeuern --> missing varargs!?

* Collections probleme: Alles polymorph?
  ich weiß nicht mehr, was damit gemeint ist
* Dialogue Acts
  - hierarchy of Frames from the ontology with access functions
  - Nesting depth > 1 ?
  - TDL syntax statt CCG würg?

* processor / abstract processor
  + behaviour sync
    - with optional delays ? (before/after)

* Application examples
  - PAL system
  - Robo demo
  - HySociaTea SB demo
  - Herbea

* Softwarepraktikum
** usability questionnaires / templates
   - which tools
   - how to debug
   - what works
   - what is awkward
   - report bugs

* DONE
+ Timeouts mit "Argumenten", die spezifische Instanzen beackern.
+ hierarchy of DAs
+ functionality: integrate jtfs for subsumption etc.
+ Final refactoring logging
  + Serialize DialogueAct to / from RDF
  + Magic Variable expansion in DialogueActs:
    slotnames *and* arguments with the same name as existing variables are
    replaced by the value of the variable, just as with {...}
    --> create an issue to *REMOVE* this //done
+ Implementation Patterns and Caveats
  + lastDAProcessed() before in propose: lastDA().theme :( //done
  + lastDAProcessed() after emitDA :( //done
  + in general: emitDA suspends the thread of commands!!! //done
  + if a question was asked: use waitingForResponse()
+ Fragen aus dem Durchforsten von VisitorType
  + ist dokumentiert, dass folgendes ein "clear" ist: //done
    child.name = null
  + done in 3.1.2, needs more detail! What turns into what.
