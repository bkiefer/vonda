\section{The RDF database HFC}

\vonda follows the information state/update paradigm. The information state is
realized by an RDF store and reasoner with special capabilities
(HFC \cite{krieger2013efficient}), namely the
possibility to directly use $n$-tuples instead of triples. This allows to
attach temporal information to every data chunk \cite{Krieger:FOIS2012,
  krieger2014detailed}. In this way, the RDF store can represent \emph{dynamic
  objects}, using either \emph{transaction time} or \emph{valid time}
attachments, and as a side effect obtain a complete history of all changes.
HFC is very efficient in terms of processing speed and memory footprint, and
has recently be extended with stream reasoning facilities. \vonda can use HFC
either directly as a library, or as a remote server, also allowing for more
than one instance, if needed.

The following is the syntax of HFC queries (EBNF):
\begin{table}[htbp]
  \centering\small
\begin{verbatim}
<query>     ::= <select> <where> [<filter>] [<aggregate>] | ASK <groundtuple>
<select>    ::= {"SELECT" | "SELECTALL"} ["DISTINCT"] {"*" | <var>^+}
<var>       ::= "?"{a-zA-Z0-9}^+ | "?_"
<nwchar>    ::= any NON-whitespace character
<where>     ::= "WHERE" <tuple> {"&" <tuple>}^*
<tuple>     ::= <literal>^+
<gtuple>    ::= <constant>^+
<literal>   ::= <var> | <constant>
<constant>  ::= <uri> | <atom>
<uri>       ::= "<" <nwchar>^+ ">"
<atom>      ::= "\""  <char>^* "\"" [ "@" <langtag> | "^^" <xsdtype> ]
<char>      ::= any character, incl. whitespaces, numbers, even '\"'
<langtag>   ::= "de" | "en" | ...
<xsdtype>   ::= "<xsd:int>" | "<xsd:long>" | "<xsd:float>" | "<xsd:double>" |
                "<xsd:dateTime>" | "<xsd:string>" | "<xsd:boolean>" | "<xsd:date>" |
                "<xsd:gYear>" | "<xsd:gMonthDay>" | "<xsd:gDay>" | "<xsd:gMonth>" |
                "<xsd:gYearMonth>" | "<xsd:duration>" | "<xsd:anyURI>" | ...
<filter>    ::= "FILTER" <constr> {"&" <constr>}^*
<constr>    ::= <ineq> | <predcall>
<ineq>      ::= <var> "!=" <literal>
<predcall>  ::= <predicate> <literal>^*
<predicate> ::= <nwchar>^+
<aggregate> ::= "AGGREGATE" <funcall> {"&" <funcall>}^*
<funcall>   ::= <var>^+ "=" <function> <literal>^*
<function>  ::= <nwchar>^+
\end{verbatim}
  \caption{BNF of the database query language}
  \label{tab:hfcquerybnf}
\end{table}

\paragraph{Notes}

The reserved symbols \texttt{ASK}, \texttt{SELECT}, \texttt{SELECTALL},
\texttt{DISTINCT}, \texttt{WHERE}, \texttt{FILTER} and \texttt{AGGREGATE}
do \emph{not} need to be written in uppercase.

Neither \texttt{filter} predicates nor \texttt{aggregate} functions should be named like reserved symbols.

\emph{don't-care} variables should be marked \emph{explicitely} by using
\verb|?_|, particularly if \texttt{SELECT} is used with \verb|*| as in:
\begin{verbatim}
     SELECT DISTINCT * WHERE ?s <rdf:type> ?_
     SELECT * WHERE ?s <rdf:type> ?o ?_ ?_
\end{verbatim}
To change the object position without projecting it you can use \emph{don't-care} variables:
\begin{verbatim}
     SELECT ?s WHERE ?s <rdf:type> ?o ?_ ?_ FILTER ?o != <foo-class>
\end{verbatim}

Aggregates in HFC take whole tables or parts of them and calculate a result based on their entities. As the type of aggregates and filter functions cannot be overloaded, there are multiple similar functions for different types, e.g. F for \texttt{float}, L for \texttt{long}, D for \texttt{double}, I
for \texttt{int}, and S for \texttt{String}.

\begin{table}[htbp]
  \centering
 \begin{tabular}{lll}
   CountDistinct&  FSum&             LMax\\
   Count&          FMean&            LMean\\
   DMean&          LGetFirst2&       LMin\\
   DSum&           LGetLatest2&      LSum\\
   DTMax&          LGetLatest&       LGetLatestValues\\
   DTMin&          LGetTimestamped2& Identity     \\
 \end{tabular}
  \caption{Available aggregates}
  \label{tab:hfcaggregates}
\end{table}

Apart from \verb|==| and \verb|!=|, funcitonal operators can be used in \texttt{filter} expressions as well. As for aggregates, there are multiple versions of the same function for different datatypes.

\begin{table}[htbp]
  \centering\small
\begin{tabular}{llll}
CardinalityNotEqual &        FNotEqual &               IntStringToBoolean &      LMin \\
Concatenate &                FProduct &                IProduct &                LNotEqual \\
DTIntersectionNotEmpty &     FQuotient &               IQuotient &               LProduct \\
DTLessEqual &                FSum &                    IsAtom &                  LQuotient \\
DTLess &                     GetDateTime &             IsBlankNode &             LSum \\
DTMax2 &                     GetLongTime &             IsNotSubtypeOf &          LValidInBetween\\
DTMin2 &                     HasLanguageTag &          ISum &                    MakeBlankNode \\
EquivalentClassAction &      IDecrement &              IsUri &                   MakeUri \\
EquivalentClassTest &        IDifference &             LDecrement &              NoSubClassOf \\
EquivalentPropertyAction &   IEqual &                  LDifference &             NoValue \\
EquivalentPropertyTest &     IGreaterEqual &           LEqual &                  PrintContent \\
FDecrement &                 IGreater &                LGreaterEqual &           PrintFalse \\
FDifference &                IIncrement &              LGreater &                PrintSize \\
FEqual &                     IIntersectionNotEmpty &   LIncrement &              PrintTrue \\
FGreaterEqual &              ILessEqual &              LIntersectionNotEmpty &   SameAsAction \\
FGreater &                   ILess &                   LIsValid &                SameAsTest \\
FIncrement &                 IMax2 &                   LLessEqual &              SContains.java\\
FLessEqual &                 IMax &                    LLess &                   UDTLess \\
FLess &                      IMin2 &                   LMax2 \\
FMax &                       IMin &                    LMax \\
FMin &                       INotEqual &               LMin2 \\
\end{tabular}
\caption{Available filter functions}
  \label{tab:hfcfunctions}
\end{table}

\subsection{Usage of HFC in \vonda}

The RDF store contains the dynamic and the terminological knowledge:
specifications for the data objects and their properties, as well as a
hierarchy of  dialogue acts,  semantic frames and their arguments. These
specifications are also used by the compiler to infer the types for property
values (see section \ref{sec:language}), and form a declarative API to
connect new components, e.g., for sensor or application data.

The ontology contains the definitions of dialogue acts, semantic frames, class
and property specifications for the data objects of the application, and other
assertional knowledge, such as specifications for ``forgetting'', which could
be modeled in an orthogonal class hierarchy, and supported by custom deletion
rules in the reasoner.
